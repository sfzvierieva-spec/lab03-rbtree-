# Лабораторна робота 3: Система рейтингу гравців

## Опис проекту

Консольний застосунок для демонстрації системи рейтингу гравців League of Legends з використанням **Розширеного Червоно-Чорного Дерева** (Augmented Red-Black Tree).

## Структура проекту

```
├── DataStructures/
│   └── AugmentedRedBlackTree.cs   # Розширене червоно-чорне дерево
├── Implementations/
│   ├── ILeaderboard.cs            # Інтерфейс системи рейтингу
│   └── RBTreeLeaderboard.cs       # Реалізація рейтингу через дерево
├── Models/
│   ├── Player.cs                  # Модель гравця (MMR, перемоги, ранг)
│   ├── PlayerComparer.cs          # Компаратор для сортування гравців
│   ├── PlayerGenerator.cs         # Генератор тестових даних
│   └── RankTier.cs               # Ранги (Iron → Challenger)
├── UI/
│   └── LeaderboardDisplay.cs     # Відображення в консолі
└── Program.cs                    # Головне меню та логіка
```

## Функціональність

- Пошук гравця за іменем
- Перегляд гравців за рангом
- Топ-10 гравців
- Розподіл за рангами
- Оновлення MMR гравця
- Швидке завантаження 1,000,000 гравців

## Завдання для реалізації

### 1. `Models/PlayerComparer.cs:10`
**Метод:** `Compare(Player? x, Player? y)`

**Мета:** Реалізувати порівняння гравців для сортування в дереві.

**Виконано:**
- Первинне сортування: за MMR (за спаданням - вищий MMR = вищий ранг)
- Вторинне сортування (при однаковому MMR): за іменем гравця (за зростанням - алфавітний порядок)
- Оброблено всі можливі випадки вхідних параметрів

---

### 2. `DataStructures/AugmentedRedBlackTree.cs:248`
**Метод:** `GetNodeAtRank(Node? node, int rank)`

**Мета:** Знайти вузол дерева за його рангом (позицією у відсортованому порядку).

**Виконано:**
- Використано поле `Size` кожного вузла для ефективного пошуку
- Порівнювняно `rank` з `Size(node.left)` для вибору напрямку пошуку
- Розглянуто 3 випадки, див. нотатки в курсі

---

### 3. `DataStructures/AugmentedRedBlackTree.cs:420`
**Метод:** `RotateLeft(Node x)`

**Мета:** Виконати ліву ротацію вузла для балансування дерева.

**Виконано:**
- Стандартний алгоритм лівої ротації червоно-чорного дерева
- **Важливо:** Оновлене поле `Size` для вузлів після ротації
- Коректно оновлене посилання `Parent`, `Left`, `Right`

---

### 4. `DataStructures/AugmentedRedBlackTree.cs:427`
**Метод:** `RotateRight(Node y)`

**Мета:** Виконати праву ротацію вузла для балансування дерева.

**Вионано:**
- Стандартний алгоритм правої ротації червоно-чорного дерева
- **Важливо:** Оновлене поле `Size` для вузлів після ротації
- Коректно оновлене посилання `Parent`, `Left`, `Right`

---

### 5. `Implementations/RBTreeLeaderboard.cs:84`
**Метод:** `UpdatePlayerMMR(string summonerName, int newMMR)`

**Мета:** Оновити MMR гравця та перемістити його у правильну позицію рейтингу.

---

### 6. `Implementations/RBTreeLeaderboard.cs:89`
**Метод:** `GetRankDistribution()`

**Мета:** Порахувати кількість гравців у кожному рангу (Iron, Bronze, Silver, ..., Challenger).

**Вимоги:**
- Повернуто `Dictionary<RankTier, int>`
- Підрахувано кількість гравців для кожного `RankTier`
- Очікувана складність: O(n)

---

## Запуск проекту

```bash
dotnet run
```

## Тестування

Програма автоматично генерує 1,000,000 гравців при запуску. Використовуйте меню для перевірки реалізованих методів.
